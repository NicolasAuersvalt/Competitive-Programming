#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

int n;
vector<ll> tree;

// CONSTRUÇÃO — O(N)
void build(const vector<int>& input) {
    for (int i = 0; i < n; i++)
        tree[n + i] = input[i];

    for (int i = n - 1; i >= 1; i--)
        tree[i] = tree[2 * i] + tree[2 * i + 1];
}

// UPDATE — O(log N)
void update(int p, int value) {
    p += n;            // vai para a folha
    tree[p] = value;  // atualiza

    for (p /= 2; p >= 1; p /= 2)
        tree[p] = tree[2 * p] + tree[2 * p + 1];
}

// QUERY — O(log N)
// intervalo [l, r], 0-based
ll query(int l, int r) {
    ll sum = 0;
    l += n; r += n;

    while (l <= r) {
        if (l & 1) sum += tree[l++];
        if (!(r & 1)) sum += tree[r--];
        l >>= 1; r >>= 1;
    }
    return sum;
}




// USO COM PONTEIRO


// Ponteiro para os dados internos da árvore
ll *p = tree.data();

// Exemplo de acesso
ll raiz = p[1];        // nó raiz
ll primeira_folha = p[n];






// USO SEM PONTEIRO

int q;
cin >> n >> q;

tree.assign(2 * n, 0);

vector<int> input(n);
for (int i = 0; i < n; i++)
    cin >> input[i];

build(input);

while (q--) {
    int type, a, b;
    cin >> type >> a >> b;

    if (type == 1) {
        update(a - 1, b);          // atualiza posição
    } else {
        cout << query(a - 1, b - 1) << "\n"; // soma no intervalo
    }
}